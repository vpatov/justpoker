class HandOptions {
    constructor() {
        this.size = 7;
    }
}

var CardName;
(function (CardName) {
    CardName[CardName["Ace"] = 0] = "Ace";
    CardName[CardName["Two"] = 1] = "Two";
    CardName[CardName["Three"] = 2] = "Three";
    CardName[CardName["Four"] = 3] = "Four";
    CardName[CardName["Five"] = 4] = "Five";
    CardName[CardName["Six"] = 5] = "Six";
    CardName[CardName["Seven"] = 6] = "Seven";
    CardName[CardName["Eight"] = 7] = "Eight";
    CardName[CardName["Nine"] = 8] = "Nine";
    CardName[CardName["Ten"] = 9] = "Ten";
    CardName[CardName["Jack"] = 10] = "Jack";
    CardName[CardName["Queen"] = 11] = "Queen";
    CardName[CardName["King"] = 12] = "King";
    CardName[CardName["Joker"] = 13] = "Joker";
})(CardName || (CardName = {}));

var Suit;
(function (Suit) {
    Suit[Suit["Clubs"] = 0] = "Clubs";
    Suit[Suit["Spades"] = 1] = "Spades";
    Suit[Suit["Diamonds"] = 2] = "Diamonds";
    Suit[Suit["Hearts"] = 3] = "Hearts";
})(Suit || (Suit = {}));

var ChipColor;
(function (ChipColor) {
    ChipColor[ChipColor["Red"] = 0] = "Red";
    ChipColor[ChipColor["Blue"] = 1] = "Blue";
    ChipColor[ChipColor["Green"] = 2] = "Green";
    ChipColor[ChipColor["Black"] = 3] = "Black";
    ChipColor[ChipColor["White"] = 4] = "White";
    ChipColor[ChipColor["Pink"] = 5] = "Pink";
    ChipColor[ChipColor["Gold"] = 6] = "Gold";
    ChipColor[ChipColor["Yellow"] = 7] = "Yellow";
    ChipColor[ChipColor["Purple"] = 8] = "Purple";
    ChipColor[ChipColor["Brown"] = 9] = "Brown";
    ChipColor[ChipColor["Gray"] = 10] = "Gray";
})(ChipColor || (ChipColor = {}));

var ChipColorType;
(function (ChipColorType) {
    ChipColorType[ChipColorType["Standard"] = 0] = "Standard";
    ChipColorType[ChipColorType["California"] = 1] = "California";
    ChipColorType[ChipColorType["WynnLasVegas"] = 2] = "WynnLasVegas";
})(ChipColorType || (ChipColorType = {}));

var Difficulty;
(function (Difficulty) {
    Difficulty[Difficulty["Easy"] = 0] = "Easy";
    Difficulty[Difficulty["Normal"] = 1] = "Normal";
    Difficulty[Difficulty["Hard"] = 2] = "Hard";
    Difficulty[Difficulty["Expert"] = 3] = "Expert";
})(Difficulty || (Difficulty = {}));

/**
 * Compares objects using `JSON.stringify`
 */
class StringifyComparer {
    areEquivalent(objA, objB) {
        return JSON.stringify(objA) === JSON.stringify(objB);
    }
}

class MapExtensions {
    /**
     * Handy method to create an ES6 Map
     * with a grouping of keys.
     *
     * https://stackoverflow.com/a/38327540
     *
     * @example
     *
     * MapExtensions.GroupBy(cards, card => card.suit);
     *
     * @param list Array of objects to group
     * @param keyGetter Key to group by. "obj => obj.key"
     */
    static GroupBy(list, keyGetter) {
        const map = new Map();
        list.forEach((item) => {
            const key = keyGetter(item);
            const collection = map.get(key);
            if (!collection) {
                map.set(key, [item]);
            }
            else {
                collection.push(item);
            }
        });
        return map;
    }
}

/**
 * Contains `static` methods which expose
 * iterable helpers. These methods can be found
 * in `aureooms/js-itertools` - https://aureooms.github.io/js-itertools/.
 *
 * The functions were adapted to fit needs, including adding generics support for
 * tooling assistance.
 */
class IterableExtensions {
    /**
     * Generator function to return combinations of an iterable object
     * Intended for use in `for..of` loops.
     * @param iterable object array to produce combinations of
     * @param size returns combination results of specified size
     */
    /* istanbul ignore next */
    static *Combinations(iterable, size) {
        let pool = Array.from(iterable);
        if (size > pool.length) {
            return [];
        }
        let indices = Array.from(this.Range(0, size, 1));
        yield Array.from(this.Pick(pool, indices));
        while (true) {
            let i = size - 1;
            while (true) {
                if (i < 0) {
                    return [];
                }
                if (indices[i] !== (i + pool.length - size)) {
                    let pivot = ++indices[i];
                    for (++i; i < size; ++i) {
                        indices[i] = ++pivot;
                    }
                    break;
                }
                --i;
            }
            yield Array.from(this.Pick(pool, indices));
        }
    }
    /**
     * Generator function to yield objects in list.
     * Intended for use in `for..of` loops.
     * @param object object to pick from
     * @param keys indexes of the object
     */
    static *Pick(object, keys) {
        for (let key of keys) {
            yield object[key];
        }
    }
    /**
     * Create an iterable range of numbers
     * Intended for use in `for..of` loops.
     * @param start First number returned from iterated range
     * @param stop Will stop before this number
     * @param step Steps between `start` and `stop`
     */
    static *Range(start, stop, step) {
        if (step < 0) {
            for (; start > stop; start += step)
                yield start;
        }
        else {
            for (; start < stop; start += step)
                yield start;
        }
    }
}

var PokerHandType;
(function (PokerHandType) {
    PokerHandType[PokerHandType["HighCard"] = 0] = "HighCard";
    PokerHandType[PokerHandType["OnePair"] = 1] = "OnePair";
    PokerHandType[PokerHandType["TwoPair"] = 2] = "TwoPair";
    PokerHandType[PokerHandType["ThreeOfAKind"] = 3] = "ThreeOfAKind";
    PokerHandType[PokerHandType["Straight"] = 4] = "Straight";
    PokerHandType[PokerHandType["Flush"] = 5] = "Flush";
    PokerHandType[PokerHandType["FullHouse"] = 6] = "FullHouse";
    PokerHandType[PokerHandType["FourOfAKind"] = 7] = "FourOfAKind";
    PokerHandType[PokerHandType["StraightFlush"] = 8] = "StraightFlush";
    PokerHandType[PokerHandType["RoyalFlush"] = 9] = "RoyalFlush";
})(PokerHandType || (PokerHandType = {}));

class InvalidArgumentError extends Error {
    constructor(message) {
        super(`Invalid Argument: ${message || ''}`);
    }
}

class PokerScoringError extends Error {
    constructor(message) {
        super(`Poker Scoring: ${message || ''}`);
    }
}

class DeckOptions {
    constructor() {
        this.extraCards = [];
        this.numberOfDecks = 1;
    }
}

/**
 * Generate a random string
 */
class MathRandomStringService {
    get(length, charSet) {
        let text = '';
        charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < length; i++) {
            text += charSet.charAt(Math.floor(Math.random() * charSet.length));
        }
        return text;
    }
}

/**
 * Shuffle one card to a random location
 * for each card in the deck.
 *
 * If one card or less is provided, an Error
 * will throw that the cards could not be shuffled.
 */
class DurstenfeldShuffleService {
    /**
     * Durstenfeld shuffle algorithm
     */
    shuffle(cards) {
        const length = cards.length;
        if (length < 2) {
            throw new Error('Not enough cards to shuffle');
        }
        for (let i = length; i; i--) {
            const n = Math.floor(Math.random() * i);
            [cards[i - 1], cards[n]] = [cards[n], cards[i - 1]];
        }
        return cards;
    }
}

/**
 * Represents a generic card.
 */
class Card {
    constructor(cardName) {
        this.cardName = cardName;
    }
    toString() {
        return `${CardName[this.cardName]}`;
    }
    getIndex() {
        return this.toString();
    }
}

/**
 * Represents a card that contains a Suit
 * and a Value (Rank).
 */
class PlayingCard extends Card {
    constructor(cardName, suit) {
        super(cardName);
        this.suit = suit;
    }
    toString() {
        return `${CardName[this.cardName]} of ${Suit[this.suit]}`;
    }
}

/**
 * Represents a Joker card which is
 * not contained within any specific Suit
 * and can have a value based on current Game (if any/if used).
 */
class JokerCard extends Card {
    constructor(cardName = CardName.Joker) {
        super(cardName);
    }
}

class RankSet {
    constructor() {
        this.rankSet = [];
    }
    cardHigherThan(thisCard, compareCard) {
        return this.getRankValue(thisCard) > this.getRankValue(compareCard);
    }
    getRankValue(card) {
        return this.rankSet.indexOf(card.cardName);
    }
}

class AceHighRankSet extends RankSet {
    constructor() {
        super(...arguments);
        this.rankSet = [
            CardName.Joker,
            CardName.Two,
            CardName.Three,
            CardName.Four,
            CardName.Five,
            CardName.Six,
            CardName.Seven,
            CardName.Eight,
            CardName.Nine,
            CardName.Ten,
            CardName.Jack,
            CardName.Queen,
            CardName.King,
            CardName.Ace
        ];
    }
}

class AceLowRankSet extends RankSet {
    constructor() {
        super(...arguments);
        this.rankSet = [
            CardName.Joker,
            CardName.Ace,
            CardName.Two,
            CardName.Three,
            CardName.Four,
            CardName.Five,
            CardName.Six,
            CardName.Seven,
            CardName.Eight,
            CardName.Nine,
            CardName.Ten,
            CardName.Jack,
            CardName.Queen,
            CardName.King
        ];
    }
}

class PokerHandResult {
    constructor(cards = [], value = 0, cardsUsed = [], rankSet = new AceHighRankSet()) {
        /**
         * Comparable value of current hand
         * to rank above or below another
         * `PokerHandResult`.
         */
        this.value = 0;
        /**
         * All cards used to determine
         * result.
         */
        this.cards = [];
        /**
         * Cards in result.
         */
        this.cardsUsed = [];
        this.cards = cards;
        this.value = value;
        this.cardsUsed = cardsUsed;
        this.rankSet = rankSet;
    }
    /**
     * Cards that were used when scoring the hand
     * but had no impact on the score itself. Used to
     * help determine a winner in event of a tied score value.
     */
    get kickers() {
        const cardsNotUsedInResult = this.cards.filter((c) => this.cardsUsed.map(u => u.getIndex()).indexOf(c.getIndex()) === -1)
            .sort((a, b) => this.rankSet.getRankValue(b) - this.rankSet.getRankValue(a));
        return [...cardsNotUsedInResult];
    }
    /**
     * Unique list of `CardName` objects that had a play
     * in `PokerHandResult.value`.
     *
     * If you want every card that played a part
     * in the value, see the `PokerHandResult.cardsUsed` property.
     */
    get scoringHandCardNames() {
        const sortedCardsUsed = this.cardsUsed.sort((a, b) => this.rankSet.getRankValue(b) - this.rankSet.getRankValue(a));
        const uniqueCardNames = new Set(sortedCardsUsed.map(c => c.cardName));
        return [...uniqueCardNames];
    }
    setHandType(type) {
        this.handType = type;
        return this;
    }
    toString() {
        if (this.handType === undefined) {
            return '';
        }
        return PokerHandType[this.handType]
            // Look for long acronyms and filter out the last letter
            .replace(/([A-Z]+)([A-Z][a-z])/g, ' $1 $2')
            // Look for lower-case letters followed by upper-case letters
            .replace(/([a-z\d])([A-Z])/g, '$1 $2')
            // Look for lower-case letters followed by numbers
            .replace(/([a-zA-Z])(\d)/g, '$1 $2')
            .replace(/^./, function (str) { return str.toUpperCase(); })
            // Remove any white space left around the word
            .trim();
    }
}

/**
 * Basic class to represent a grouping of ICards.
 *
 * Supports activities like: getting list of cards,
 * adding cards to group, taking first card, taking
 * multiple cards, getting count of cards, and shuffling
 * the cards.
 */
class CardCollection {
    constructor(cards = []) {
        this.cards = cards;
        /**
         * Friendly name of card collection that
         * means something: "Hand", "Discard Pile",
         * "In Play", etc.
         */
        this.name = '';
        this.shuffleService = new DurstenfeldShuffleService();
        this.objectComparer = new StringifyComparer();
    }
    addCard(card) {
        return this.addCards([card]);
    }
    addCards(cards) {
        this.getCards().unshift(...cards);
        return this;
    }
    removeCards(cards) {
        cards.forEach((card) => {
            const position = this.indexOfCard(card);
            if (position > -1) {
                this.getCards().splice(position, 1);
            }
            else {
                throw new Error('Card does not exist in collection');
            }
        });
        return this;
    }
    takeCard() {
        if (!this.isEmpty()) {
            return this.getCards().shift();
        }
        throw new Error('No cards remaining in pile');
    }
    /**
     * Remove cards from hand.
     * @param amount Amount of cards to remove from Hand. If less than 1, all cards are taken.
     */
    takeCards(amount) {
        if (!amount || amount < 1) {
            amount = this.getCount();
        }
        // tslint:disable-next-line:prefer-const
        let pulledCards = [];
        while (!this.isEmpty() && pulledCards.length < amount) {
            pulledCards.push(this.getCards().shift());
        }
        return pulledCards;
    }
    getCards() {
        return this.cards;
    }
    setCards(cards) {
        this.cards = cards;
        return this;
    }
    hasCard(card) {
        return this.getCards().some((c) => c.getIndex() === card.getIndex());
    }
    hasCards(cards) {
        if (!this.hasCard(cards.shift())) {
            return false;
        }
        if (cards && cards.length > 0) {
            return this.hasCards(cards);
        }
        else {
            return true;
        }
    }
    getCount() {
        return this.getCards().length;
    }
    isEmpty() {
        return this.getCount() === 0;
    }
    shuffle() {
        this.setCards(this.shuffleService.shuffle(this.getCards()));
    }
    indexOfCard(card) {
        for (let i = 0; i < this.getCount(); i++) {
            const loopCard = this.getCards()[i];
            if (this.objectComparer.areEquivalent(card, loopCard)) {
                return i;
            }
        }
        return -1;
    }
    cardAtIndex(index) {
        if (index >= 0 && index <= (this.getCount() - 1)) {
            return this.getCards()[index];
        }
        else {
            throw new Error('Card collection does not contain card at index');
        }
    }
}

/**
 * Extending the basic CardCollection, this class supports
 * dealing with cards in an ordered pile. As such, interacting
 * with the pile from the bottom is supported by using this
 * class.
 */
class CardPile extends CardCollection {
    constructor(cards = []) {
        super(cards); // CardCollection.constructor
        this.name = 'Pile';
    }
    addCardsToBottom(cards) {
        this.setCards(this.getCards().concat(cards));
    }
    takeCardFromBottom() {
        if (!this.isEmpty()) {
            return this.getCards().pop();
        }
        throw new Error('No cards remaining in pile');
    }
    takeCardsFromBottom(amount) {
        let pulledCards = [];
        while (!this.isEmpty() && pulledCards.length < amount) {
            pulledCards.push(this.getCards().pop());
        }
        return pulledCards;
    }
}

/**
 * Represents a group of cards assigned to an IPlayer
 */
class Hand extends CardPile {
    constructor(cards = []) {
        super(cards); // CardPile.constructor
        this.name = 'Hand';
        this.suitOrder = [Suit.Clubs, Suit.Spades, Suit.Diamonds, Suit.Hearts];
    }
    /**
     * Performs action of removing a card from player hand.
     *
     * Throws error if `ICard` played is not in player's hand.
     * @param card - Card being played
     */
    playCard(card) {
        this.removeCards([card]);
    }
    /**
     * Order cards in Hand by Rank and Suit
     * @see Hand.suitOrder
     */
    sortCards(cardRank) {
        const cards = this.getCards();
        if (this.isEmpty()) {
            throw new Error('No cards to sort');
        }
        if (this.suitOrder.length === 0) {
            throw new Error('No suit order defined');
        }
        let sortedCardsBySuit = [];
        const cardsBySuit = new Map(Array.from(MapExtensions.GroupBy(cards, (card) => this.suitOrder.indexOf(card.suit)).entries()).sort());
        cardsBySuit.forEach((suitCards) => {
            sortedCardsBySuit = sortedCardsBySuit.concat(suitCards.sort((a, b) => {
                return cardRank.getRankValue(a) - cardRank.getRankValue(b);
            }));
        });
        this.setCards(sortedCardsBySuit);
        return this;
    }
}

/**
 * Deck represents the source of cards in play. As such,
 * a Deck is merely a pile of cards that are drawn from
 * throughout the duration of the ongoing game.
 */
class Deck extends CardPile {
    constructor(cards = []) {
        super(cards);
        this.name = 'Deck';
    }
    static BuildFrom(cards = []) {
        return new Deck(cards);
    }
    static Build(suits, cardNames, extraCards = []) {
        let cards = [];
        suits.forEach((suit) => cardNames.forEach((cardName) => cards.push(new PlayingCard(cardName, suit))));
        if (extraCards && extraCards.length > 0) {
            cards = cards.concat(extraCards);
        }
        return new Deck(cards);
    }
    createHand(options) {
        const hand = new Hand();
        this.deal(hand, options.size, false);
        return hand;
    }
    deal(hand, /** Amount of cards to deal into Hand */ size, /** Deal cards to top of hand */ frontOfHand = false) {
        if (frontOfHand) {
            hand.addCards(this.takeCards(size));
        }
        else {
            hand.addCardsToBottom(this.takeCards(size));
        }
        return this;
    }
}

/**
 * Represents a generic chip - typically used
 * in Poker style games.
 */
class Chip {
    constructor(color, colorType = ChipColorType.Standard, overrideValue = 0) {
        this.color = color;
        this.colorType = colorType;
        this.overrideValue = overrideValue;
        this.valueMap = new Map();
    }
    toString() {
        return `${ChipColor[this.color]}`;
    }
    getValue(_color = this.color) {
        if (this.overrideValue !== 0) {
            return this.overrideValue;
        }
        if (this.valueMap.has(_color)) {
            return this.valueMap.get(_color);
        }
        else {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            `Unable to determine value of ${ChipColor[_color]} Chip for ${ChipColorType[this.colorType]}`);
        }
    }
    setValue(amount) {
        this.overrideValue = amount;
        return this;
    }
    setColorValue(color, amount) {
        this.valueMap.set(color, amount);
        return this;
    }
    getIndex() {
        return this.toString();
    }
}

/**
 * Represents a Standard valuing Chip
 */
class StandardChip extends Chip {
    constructor(color, colorType = ChipColorType.Standard, overrideValue = 0) {
        super(color, colorType, overrideValue);
        this.configureDefaultColorValues();
    }
    configureDefaultColorValues() {
        this
            .setColorValue(ChipColor.White, 1)
            .setColorValue(ChipColor.Red, 5)
            .setColorValue(ChipColor.Blue, 10)
            .setColorValue(ChipColor.Gray, 20)
            .setColorValue(ChipColor.Green, 25)
            .setColorValue(ChipColor.Black, 100);
    }
}

/**
 * Represents a California valuing Chip
 */
class CaliforniaChip extends Chip {
    constructor(color, colorType = ChipColorType.California, overrideValue = 0) {
        super(color, colorType, overrideValue);
        this.configureDefaultColorValues();
    }
    configureDefaultColorValues() {
        this
            .setColorValue(ChipColor.Blue, 1)
            .setColorValue(ChipColor.Green, 2)
            .setColorValue(ChipColor.Red, 3)
            .setColorValue(ChipColor.Yellow, 5)
            .setColorValue(ChipColor.Brown, 10)
            .setColorValue(ChipColor.Black, 20)
            .setColorValue(ChipColor.Purple, 25)
            .setColorValue(ChipColor.White, 100)
            .setColorValue(ChipColor.Gray, 500);
    }
}

class ChipService {
    /**
     * The service should accept an `IChipCollection` and
     * a requested specific amount of chip value, and be able to
     * "break" or "make change" to swap out chips to meet that
     * exact need. These chips are removed from the incoming
     * `chipCollection` and the return value are chips that
     * match the `needValue` requested.
     * @param chipCollection Chips to create `needValue` from
     * @param needValue Amount requested from chips
     * @param chipType Class of Chip to return
     */
    makeChange(chipCollection, needValue, chipType = StandardChip, colorUp = false) {
        const currentValue = chipCollection.getValue();
        if (needValue > currentValue) {
            throw new Error(`Not enough chips (${currentValue}) to satisfy requested amount ${needValue}`);
        }
        else if (needValue <= 0) {
            throw new Error(`makeChange requires a positive Chip amount needed`);
        }
        if (colorUp && chipCollection.getChipCount() > 1) {
            const coloredUp = this.sortByValue(this.colorUp(chipCollection.getChips(), chipType));
            chipCollection.setChips(coloredUp);
        }
        // set aside high chips
        let chips = this.sortByValue(chipCollection.getChips());
        let highChips = [];
        if (chipCollection.getChipCount() > 1) {
            let n = chipCollection.getChipCount() - 1;
            while (n > 0) {
                if (this.valueOfChips(chips.slice(0, n)) > needValue) {
                    highChips.push(...chips.splice(n, 1));
                }
                else {
                    break;
                }
                n--;
            }
        }
        let matchedCombination = this.hasCombinationOfAmount(needValue, chips);
        if (matchedCombination.length > 0) {
            chipCollection.removeChips(matchedCombination);
            return [...matchedCombination];
        }
        const breakChip = this.getNextChipToBreak(chips, needValue);
        chipCollection.removeChips([breakChip]);
        const newChips = this.createChips(breakChip.getValue(), false, chipType);
        chipCollection.addChips([...newChips]);
        return this.makeChange(chipCollection, needValue, chipType, false);
    }
    sortByValue(chips) {
        return Array.from(chips)
            .sort((a, b) => a.getValue() - b.getValue());
    }
    createChips(amount, canBeSingleChip = true, chipType = StandardChip) {
        if (amount <= 0) {
            return [];
        }
        let sampleChip = new chipType(ChipColor.White);
        let sortedChips = Array.from(sampleChip.valueMap.entries())
            .sort((a, b) => {
            return a[1] - b[1];
        });
        const chipsThatCanFulfillValue = sortedChips
            .filter((combo) => combo[1] <= amount).length;
        if (chipsThatCanFulfillValue === 1) {
            canBeSingleChip = true;
        }
        let availableChips = sortedChips
            .filter((combo) => canBeSingleChip ? combo[1] <= amount
            : combo[1] < amount)
            .map((entry) => new chipType(entry[0]));
        if (availableChips.length < 1) {
            throw new Error(`Incompatible Chip class to fulfill a value of '${amount}'`);
        }
        let index = availableChips.length - 1;
        const createdChips = [];
        while (amount >= availableChips[0].getValue()) {
            if (amount >= availableChips[index].getValue()) {
                amount -= availableChips[index].getValue();
                createdChips.push(availableChips[index]);
            }
            else {
                index--;
            }
        }
        return createdChips;
    }
    valueOfChips(chips) {
        if (chips.length === 0) {
            return 0;
        }
        return chips.reduce((a, b) => a + b.getValue(), 0);
    }
    colorUp(chips, chipType = StandardChip) {
        const chipsValue = this.valueOfChips(chips);
        const canBeSingleChip = true;
        return this.createChips(chipsValue, canBeSingleChip, chipType);
    }
    hasCombinationOfAmount(amount, chips) {
        const iteratedChips = this.sortByValue(chips);
        let size = chips.length;
        let foundCombination = [];
        while (size > 0) {
            for (let combination of IterableExtensions.Combinations(iteratedChips, size)) {
                if (this.valueOfChips([...combination]) === amount) {
                    foundCombination = [...combination];
                    break; // close iterator
                }
            }
            if (foundCombination.length > 0) {
                return foundCombination;
            }
            size--;
        }
        return [];
    }
    removeChipsFromStack(chips, removeChips) {
        removeChips.forEach((chip) => {
            for (let i = 0; i < chips.length; i++) {
                if (chips[i].getIndex() === chip.getIndex()) {
                    chips.splice(i, 1);
                    break;
                }
            }
        });
        return chips;
    }
    getNextChipToBreak(chips, needValue) {
        const orderedChips = this.sortByValue(chips);
        const reverseOrderedChips = [...orderedChips].reverse();
        const pulledChips = [];
        // find first largest chip at or under value
        let i = 0;
        let runningTotal = 0;
        while (i < reverseOrderedChips.length - 1) {
            const currentChip = reverseOrderedChips[i];
            const addedChipValue = runningTotal + currentChip.getValue();
            if (addedChipValue <= needValue) {
                runningTotal = addedChipValue;
                pulledChips.push(currentChip);
            }
            i++;
        }
        if (runningTotal > 0) {
            let remainingChips = this.removeChipsFromStack([...orderedChips], pulledChips);
            i = 0;
            while (i < remainingChips.length - 1) {
                const currentChip = remainingChips[i];
                const addedChipValue = runningTotal + currentChip.getValue();
                if (addedChipValue <= needValue) {
                    runningTotal = addedChipValue;
                }
                else {
                    // we found our breakchip at remainingChips[i]
                    break;
                }
                i++;
            }
            return remainingChips[i];
        }
        else {
            return reverseOrderedChips[i];
        }
    }
}

/**
 * Basic class to represent a grouping of IChips.
 *
 * Supports activities like: getting chips,
 * adding chips, taking specific chip, taking
 * chips by value, getting value of chips.
 */
class ChipCollection {
    constructor(chips = []) {
        this.chips = chips;
        this.objectComparer = new StringifyComparer();
        this.chipService = new ChipService();
    }
    addChip(chip) {
        return this.addChips([chip]);
    }
    addChips(chips) {
        this.getChips().unshift(...chips);
        return this;
    }
    getChips() {
        return this.chips;
    }
    setChips(chips) {
        this.chips = chips;
        return this;
    }
    getChipCount() {
        return this.getChips().length;
    }
    isEmpty() {
        return this.getChipCount() === 0;
    }
    removeChips(chips) {
        if (chips.length === 0) {
            return this;
        }
        this.chipService.removeChipsFromStack(this.getChips(), chips);
        return this;
    }
    /**
     * Condense chips into fewer but larger denominations.
     * Uses the first chip's class to create new colored chips with.
     */
    colorUp() {
        if (this.getChipCount() === 0) {
            return this;
        }
        const newChips = this.chipService.colorUp(this.getChips(), this.getChips()[0].constructor);
        this.setChips(newChips);
        return this;
    }
    /**
     * Returns first identified index position of chip in
     * collection.
     * @param chip Object to search for in collection
     */
    indexOfChip(chip) {
        for (let i = 0; i < this.getChipCount(); i++) {
            const loopCard = this.getChips()[i];
            if (this.objectComparer.areEquivalent(chip, loopCard)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Return value of Chips currently in ChipCollection (via `IChipCollection.getChips()`).
     * Optionally, can pass in `IChip[]` to evaluate a manually passed in value.
     * @param chips Optional, value of passed in chips. If no chips passed in,
     * it will evaluate value of current ChipCollection.
     */
    getValue(chips) {
        if (chips === undefined) {
            chips = this.getChips();
        }
        return this.chipService.valueOfChips(chips);
    }
    /**
     * Will pull `IChip`s from `IChipCollection` to satisfy
     * the `amount` requested.
     * @param amount Value to take from IChipCollection
     */
    takeValue(amount) {
        const currentValue = this.getValue();
        if (amount > currentValue) {
            throw new Error(`Not enough chips (${currentValue}) to satisfy requested amount ${amount}`);
        }
        return this.chipService.makeChange(this, amount, this.getChips()[0].constructor);
    }
}

class BaseGameType {
    constructor() {
        this.rankSet = new AceHighRankSet();
        this.cardsAllowed = [];
    }
    createDeck(_options) {
        if (_options) {
            let gameCards = [];
            for (let i = 0; i < _options.numberOfDecks; i++) {
                gameCards.push(...this.cardsAllowed);
            }
            if (_options.extraCards && _options.extraCards.length > 0) {
                gameCards = gameCards.concat(_options.extraCards);
            }
            return Deck.BuildFrom(gameCards);
        }
        else {
            return Deck.BuildFrom(this.cardsAllowed);
        }
    }
}

/**
 * GameType with Solitaire configuration
 */
class SolitaireGameType extends BaseGameType {
    constructor() {
        super(...arguments);
        this.rankSet = new AceLowRankSet();
        this.cardsAllowed = [
            new PlayingCard(CardName.Ace, Suit.Clubs),
            new PlayingCard(CardName.Two, Suit.Clubs),
            new PlayingCard(CardName.Three, Suit.Clubs),
            new PlayingCard(CardName.Four, Suit.Clubs),
            new PlayingCard(CardName.Five, Suit.Clubs),
            new PlayingCard(CardName.Six, Suit.Clubs),
            new PlayingCard(CardName.Seven, Suit.Clubs),
            new PlayingCard(CardName.Eight, Suit.Clubs),
            new PlayingCard(CardName.Nine, Suit.Clubs),
            new PlayingCard(CardName.Ten, Suit.Clubs),
            new PlayingCard(CardName.Jack, Suit.Clubs),
            new PlayingCard(CardName.Queen, Suit.Clubs),
            new PlayingCard(CardName.King, Suit.Clubs),
            new PlayingCard(CardName.Ace, Suit.Spades),
            new PlayingCard(CardName.Two, Suit.Spades),
            new PlayingCard(CardName.Three, Suit.Spades),
            new PlayingCard(CardName.Four, Suit.Spades),
            new PlayingCard(CardName.Five, Suit.Spades),
            new PlayingCard(CardName.Six, Suit.Spades),
            new PlayingCard(CardName.Seven, Suit.Spades),
            new PlayingCard(CardName.Eight, Suit.Spades),
            new PlayingCard(CardName.Nine, Suit.Spades),
            new PlayingCard(CardName.Ten, Suit.Spades),
            new PlayingCard(CardName.Jack, Suit.Spades),
            new PlayingCard(CardName.Queen, Suit.Spades),
            new PlayingCard(CardName.King, Suit.Spades),
            new PlayingCard(CardName.Ace, Suit.Diamonds),
            new PlayingCard(CardName.Two, Suit.Diamonds),
            new PlayingCard(CardName.Three, Suit.Diamonds),
            new PlayingCard(CardName.Four, Suit.Diamonds),
            new PlayingCard(CardName.Five, Suit.Diamonds),
            new PlayingCard(CardName.Six, Suit.Diamonds),
            new PlayingCard(CardName.Seven, Suit.Diamonds),
            new PlayingCard(CardName.Eight, Suit.Diamonds),
            new PlayingCard(CardName.Nine, Suit.Diamonds),
            new PlayingCard(CardName.Ten, Suit.Diamonds),
            new PlayingCard(CardName.Jack, Suit.Diamonds),
            new PlayingCard(CardName.Queen, Suit.Diamonds),
            new PlayingCard(CardName.King, Suit.Diamonds),
            new PlayingCard(CardName.Ace, Suit.Hearts),
            new PlayingCard(CardName.Two, Suit.Hearts),
            new PlayingCard(CardName.Three, Suit.Hearts),
            new PlayingCard(CardName.Four, Suit.Hearts),
            new PlayingCard(CardName.Five, Suit.Hearts),
            new PlayingCard(CardName.Six, Suit.Hearts),
            new PlayingCard(CardName.Seven, Suit.Hearts),
            new PlayingCard(CardName.Eight, Suit.Hearts),
            new PlayingCard(CardName.Nine, Suit.Hearts),
            new PlayingCard(CardName.Ten, Suit.Hearts),
            new PlayingCard(CardName.Jack, Suit.Hearts),
            new PlayingCard(CardName.Queen, Suit.Hearts),
            new PlayingCard(CardName.King, Suit.Hearts)
        ];
    }
}

/**
 * GameType with Hearts configuration
 */
class HeartsGameType extends BaseGameType {
    constructor() {
        super(...arguments);
        this.rankSet = new AceHighRankSet();
        this.cardsAllowed = [
            new PlayingCard(CardName.Ace, Suit.Clubs),
            new PlayingCard(CardName.Two, Suit.Clubs),
            new PlayingCard(CardName.Three, Suit.Clubs),
            new PlayingCard(CardName.Four, Suit.Clubs),
            new PlayingCard(CardName.Five, Suit.Clubs),
            new PlayingCard(CardName.Six, Suit.Clubs),
            new PlayingCard(CardName.Seven, Suit.Clubs),
            new PlayingCard(CardName.Eight, Suit.Clubs),
            new PlayingCard(CardName.Nine, Suit.Clubs),
            new PlayingCard(CardName.Ten, Suit.Clubs),
            new PlayingCard(CardName.Jack, Suit.Clubs),
            new PlayingCard(CardName.Queen, Suit.Clubs),
            new PlayingCard(CardName.King, Suit.Clubs),
            new PlayingCard(CardName.Ace, Suit.Spades),
            new PlayingCard(CardName.Two, Suit.Spades),
            new PlayingCard(CardName.Three, Suit.Spades),
            new PlayingCard(CardName.Four, Suit.Spades),
            new PlayingCard(CardName.Five, Suit.Spades),
            new PlayingCard(CardName.Six, Suit.Spades),
            new PlayingCard(CardName.Seven, Suit.Spades),
            new PlayingCard(CardName.Eight, Suit.Spades),
            new PlayingCard(CardName.Nine, Suit.Spades),
            new PlayingCard(CardName.Ten, Suit.Spades),
            new PlayingCard(CardName.Jack, Suit.Spades),
            new PlayingCard(CardName.Queen, Suit.Spades),
            new PlayingCard(CardName.King, Suit.Spades),
            new PlayingCard(CardName.Ace, Suit.Diamonds),
            new PlayingCard(CardName.Two, Suit.Diamonds),
            new PlayingCard(CardName.Three, Suit.Diamonds),
            new PlayingCard(CardName.Four, Suit.Diamonds),
            new PlayingCard(CardName.Five, Suit.Diamonds),
            new PlayingCard(CardName.Six, Suit.Diamonds),
            new PlayingCard(CardName.Seven, Suit.Diamonds),
            new PlayingCard(CardName.Eight, Suit.Diamonds),
            new PlayingCard(CardName.Nine, Suit.Diamonds),
            new PlayingCard(CardName.Ten, Suit.Diamonds),
            new PlayingCard(CardName.Jack, Suit.Diamonds),
            new PlayingCard(CardName.Queen, Suit.Diamonds),
            new PlayingCard(CardName.King, Suit.Diamonds),
            new PlayingCard(CardName.Ace, Suit.Hearts),
            new PlayingCard(CardName.Two, Suit.Hearts),
            new PlayingCard(CardName.Three, Suit.Hearts),
            new PlayingCard(CardName.Four, Suit.Hearts),
            new PlayingCard(CardName.Five, Suit.Hearts),
            new PlayingCard(CardName.Six, Suit.Hearts),
            new PlayingCard(CardName.Seven, Suit.Hearts),
            new PlayingCard(CardName.Eight, Suit.Hearts),
            new PlayingCard(CardName.Nine, Suit.Hearts),
            new PlayingCard(CardName.Ten, Suit.Hearts),
            new PlayingCard(CardName.Jack, Suit.Hearts),
            new PlayingCard(CardName.Queen, Suit.Hearts),
            new PlayingCard(CardName.King, Suit.Hearts)
        ];
    }
}

/**
 * GameType with Texas Hold'Em Poker configuration
 */
class TexasHoldEmPokerGameType extends BaseGameType {
    constructor() {
        super(...arguments);
        this.rankSet = new AceHighRankSet();
        this.cardsAllowed = [
            new PlayingCard(CardName.Ace, Suit.Clubs),
            new PlayingCard(CardName.Two, Suit.Clubs),
            new PlayingCard(CardName.Three, Suit.Clubs),
            new PlayingCard(CardName.Four, Suit.Clubs),
            new PlayingCard(CardName.Five, Suit.Clubs),
            new PlayingCard(CardName.Six, Suit.Clubs),
            new PlayingCard(CardName.Seven, Suit.Clubs),
            new PlayingCard(CardName.Eight, Suit.Clubs),
            new PlayingCard(CardName.Nine, Suit.Clubs),
            new PlayingCard(CardName.Ten, Suit.Clubs),
            new PlayingCard(CardName.Jack, Suit.Clubs),
            new PlayingCard(CardName.Queen, Suit.Clubs),
            new PlayingCard(CardName.King, Suit.Clubs),
            new PlayingCard(CardName.Ace, Suit.Spades),
            new PlayingCard(CardName.Two, Suit.Spades),
            new PlayingCard(CardName.Three, Suit.Spades),
            new PlayingCard(CardName.Four, Suit.Spades),
            new PlayingCard(CardName.Five, Suit.Spades),
            new PlayingCard(CardName.Six, Suit.Spades),
            new PlayingCard(CardName.Seven, Suit.Spades),
            new PlayingCard(CardName.Eight, Suit.Spades),
            new PlayingCard(CardName.Nine, Suit.Spades),
            new PlayingCard(CardName.Ten, Suit.Spades),
            new PlayingCard(CardName.Jack, Suit.Spades),
            new PlayingCard(CardName.Queen, Suit.Spades),
            new PlayingCard(CardName.King, Suit.Spades),
            new PlayingCard(CardName.Ace, Suit.Diamonds),
            new PlayingCard(CardName.Two, Suit.Diamonds),
            new PlayingCard(CardName.Three, Suit.Diamonds),
            new PlayingCard(CardName.Four, Suit.Diamonds),
            new PlayingCard(CardName.Five, Suit.Diamonds),
            new PlayingCard(CardName.Six, Suit.Diamonds),
            new PlayingCard(CardName.Seven, Suit.Diamonds),
            new PlayingCard(CardName.Eight, Suit.Diamonds),
            new PlayingCard(CardName.Nine, Suit.Diamonds),
            new PlayingCard(CardName.Ten, Suit.Diamonds),
            new PlayingCard(CardName.Jack, Suit.Diamonds),
            new PlayingCard(CardName.Queen, Suit.Diamonds),
            new PlayingCard(CardName.King, Suit.Diamonds),
            new PlayingCard(CardName.Ace, Suit.Hearts),
            new PlayingCard(CardName.Two, Suit.Hearts),
            new PlayingCard(CardName.Three, Suit.Hearts),
            new PlayingCard(CardName.Four, Suit.Hearts),
            new PlayingCard(CardName.Five, Suit.Hearts),
            new PlayingCard(CardName.Six, Suit.Hearts),
            new PlayingCard(CardName.Seven, Suit.Hearts),
            new PlayingCard(CardName.Eight, Suit.Hearts),
            new PlayingCard(CardName.Nine, Suit.Hearts),
            new PlayingCard(CardName.Ten, Suit.Hearts),
            new PlayingCard(CardName.Jack, Suit.Hearts),
            new PlayingCard(CardName.Queen, Suit.Hearts),
            new PlayingCard(CardName.King, Suit.Hearts)
        ];
    }
}

/**
 * Represents a Player
 */
class Player {
    constructor(name = '', hand = new Hand(), randomStringService = new MathRandomStringService()) {
        this.name = name;
        this.hand = hand;
        this.score = 0;
        this.id = randomStringService.get(7);
    }
    updateScore(score) {
        this.score = score;
        return this;
    }
    getHand() {
        return this.hand;
    }
    setHand(hand) {
        this.hand = hand;
        return this;
    }
    toString() {
        return `${this.name}`;
    }
    getIndex() {
        return this.id;
    }
}

class ComputerPlayer extends Player {
    constructor(name = '', hand = new Hand(), difficulty = Difficulty.Normal) {
        super(name, hand);
        this.difficulty = difficulty;
    }
    static Create(fields) {
        const name = (fields) ? fields.name : '';
        const difficulty = (fields) ? fields.difficulty : Difficulty.Normal;
        return new ComputerPlayer(name, new Hand(), difficulty);
    }
    setDifficulty(difficulty) {
        this.difficulty = difficulty;
        return this;
    }
    toString() {
        return `Computer: ${this.name}`;
    }
}

/**
 * Extension of ES6 Map<T, U> that enforces T
 * to implement `IIndexable`, so that when
 * `Map.has` checks its internal keys, the typical
 * `object === object` match won't fail, because
 * it will use the `IIndexable.getIndex()` value
 * as the key.
 */
class IndexedMap {
    constructor() {
        this.internalMap = new Map();
    }
    add(item, value) {
        this.internalMap.set(item.getIndex(), value);
        return this;
    }
    get(item) {
        return this.internalMap.get(item.getIndex());
    }
    contains(item) {
        return this.internalMap.has(item.getIndex());
    }
    clear() {
        this.internalMap.clear();
        return this;
    }
    delete(item) {
        this.internalMap.delete(item.getIndex());
        return this;
    }
    entries() {
        return this.internalMap;
    }
}

class PokerScoreService {
    constructor() {
        this.gameType = new TexasHoldEmPokerGameType();
    }
    scoreHand(hand, communityCards = []) {
        const playerHand = [...hand.getCards().concat(communityCards)];
        if (playerHand.length < 5) {
            throw new PokerScoringError('Invalid cards provided. Please send at least 5 cards.');
        }
        return this.scoreCards(playerHand);
    }
    scoreCards(cards, communityCards = []) {
        let bestHand = new PokerHandResult();
        const playerCards = [...cards.concat(communityCards)];
        if (playerCards.length < 5) {
            throw new PokerScoringError('Invalid cards provided. Please send at least 5 cards.');
        }
        // find best hand
        for (const combination of IterableExtensions.Combinations(cards, 5)) {
            const result = this.calculate(combination);
            if (result.value > bestHand.value) {
                bestHand = result;
            }
        }
        return bestHand;
    }
    scorePlayers(players, communityCards = []) {
        const result = new IndexedMap();
        players.forEach((player) => {
            const playerHand = [...player.getHand().getCards().concat(communityCards)];
            if (playerHand.length < 5) {
                throw new PokerScoringError(`Invalid cards provided for ${player}. Please send at least 5 cards.`);
            }
            const playerScore = this.scoreCards(playerHand);
            result.add(player, playerScore);
        });
        return result;
    }
    getScoreRank(result) {
        if (result.cards.length < 5) {
            throw new PokerScoringError('Invalid cards provided. Please send at least 5 cards.');
        }
        result.value = this.value(this.ranked(result.cards), result.handType);
        return result.value;
    }
    ranked(cards) {
        // split cards by rank
        let result = [];
        for (let card of cards) {
            let r = this.gameType.rankSet.getRankValue(card);
            result[r] = result[r] || [];
            result[r].push(card);
        }
        // condense
        result = result.filter((rank) => !!rank);
        // high to low
        result.reverse();
        // pairs and sets first
        result.sort((a, b) => {
            return a.length > b.length ? -1 : a.length < b.length ? 1 : 0;
        });
        return result;
    }
    isStraight(ranked) {
        // must have 5 different cards
        if (!ranked[4]) {
            return false;
        }
        // could be wheel if r1 is 'ace' and r4 is '2'
        if (ranked[0][0].cardName === CardName.Ace &&
            ranked[1][0].cardName === CardName.Five &&
            ranked[4][0].cardName === CardName.Two) {
            // hand is 'ace' '5' '4' '3' '2'
            ranked.push(ranked.shift());
            // ace is now low
            return true;
        }
        // run of five in row is straight
        let r1 = this.gameType.rankSet.getRankValue(ranked[0][0]);
        let r4 = this.gameType.rankSet.getRankValue(ranked[4][0]);
        return (r1 - r4) === 4;
    }
    isFlush(cards) {
        // all suits match is flush
        return cards.every((card) => card.suit === cards[0].suit);
    }
    value(ranked, handType) {
        // primary wins the rest are kickers
        let str = '';
        for (let rank of ranked) {
            // create two digit value
            let r = this.gameType.rankSet.getRankValue(rank[0]);
            let v = (r < 10 ? '0' : '') + r;
            for (let i = 0; i < rank.length; i++) {
                // append value for each card
                str += v;
            }
        }
        // to integer
        return (handType * 10000000000) + parseInt(str, 10);
    }
    calculate(cards) {
        let result;
        let cardsUsed = [];
        let handType;
        const ranked = this.ranked(cards);
        const isFlush = this.isFlush(cards);
        const isStraight = this.isStraight(ranked);
        const highestPlayedCards = ranked[0];
        const rankSet = this.gameType.rankSet;
        if (isStraight && isFlush && highestPlayedCards[0].cardName === CardName.Ace) {
            cardsUsed = [ranked[0][0], ranked[1][0], ranked[2][0], ranked[3][0], ranked[4][0]];
            handType = PokerHandType.RoyalFlush;
        }
        else if (isStraight && isFlush) {
            cardsUsed = [ranked[0][0], ranked[1][0], ranked[2][0], ranked[3][0], ranked[4][0]];
            handType = PokerHandType.StraightFlush;
        }
        else if (highestPlayedCards.length === 4) {
            cardsUsed = ranked[0];
            handType = PokerHandType.FourOfAKind;
        }
        else if (ranked[0].length === 3 && ranked[1].length === 2) {
            cardsUsed = ranked[0].concat(ranked[1]);
            handType = PokerHandType.FullHouse;
        }
        else if (isFlush) {
            cardsUsed = [ranked[0][0], ranked[1][0], ranked[2][0], ranked[3][0], ranked[4][0]];
            handType = PokerHandType.Flush;
        }
        else if (isStraight) {
            cardsUsed = [ranked[0][0], ranked[1][0], ranked[2][0], ranked[3][0], ranked[4][0]];
            handType = PokerHandType.Straight;
        }
        else if (highestPlayedCards.length === 3) {
            cardsUsed = ranked[0];
            handType = PokerHandType.ThreeOfAKind;
        }
        else if (ranked[0].length === 2 && ranked[1].length === 2) {
            cardsUsed = ranked[0].concat(ranked[1]);
            handType = PokerHandType.TwoPair;
        }
        else if (highestPlayedCards.length === 2) {
            cardsUsed = ranked[0];
            handType = PokerHandType.OnePair;
        }
        else {
            cardsUsed = ranked[0];
            handType = PokerHandType.HighCard;
        }
        result = new PokerHandResult(cards, this.value(ranked, handType), cardsUsed, rankSet)
            .setHandType(handType);
        return result;
    }
}

export { HandOptions, CardName, Suit, ChipColor, ChipColorType, Difficulty, StringifyComparer, MapExtensions, IterableExtensions, PokerHandType, InvalidArgumentError, PokerScoringError, DeckOptions, MathRandomStringService, DurstenfeldShuffleService, Card, PlayingCard, JokerCard, RankSet, AceHighRankSet, AceLowRankSet, PokerHandResult, CardCollection, CardPile, Hand, Deck, Chip, StandardChip, CaliforniaChip, ChipService, ChipCollection, BaseGameType, SolitaireGameType, HeartsGameType, TexasHoldEmPokerGameType, Player, ComputerPlayer, IndexedMap, PokerScoreService };
//# sourceMappingURL=index.js.map
