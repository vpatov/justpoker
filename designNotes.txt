=================================================
Connection Initialization
=================================================

Model distinctions:

ConnectedClient - sever-side obj that represents a client that has loaded
the frontend and has connected to the server via WS.

GamePlayer - server-side obj that represents an actual game player that has
hole cards, a stack, a name, etc.

Websocket Connection - the actual WS connection (tuple of IP_Address/port)

A ConnectedClient may or may not be associated with a GamePlayer. For
example, a spectator will not have a GamePlayer association. This way, they
can use the websocket connection to spectate in real-time. If they choose to
sit down, the server will create a GamePlayer and associate the two, and the
user can now play (using the same WS connection and same cookie).


Connection sequence/plan:

1)  User visits app website, where they can fill out a new table form.
2)  User fills out form, submits to server via POST request
    form contains (at least):
        - gameType
        - blinds
        - admin password
        - (optional) admin responsibilities
            - admin must control buy-ins?
            - admin must approve new players?

3)  Server creates new table with specified params.
    Server generates unique URL, and makes table accessible at that URL,
    and sends the URL as a response to the post request.

4)  Client page redirects user to the new game URL, which has the main
    game frontend application.


5) Websocket Connection Setup

    Client:
    The client tries to estalish a websocket connection with the server.
    It will first try to find the "JustPoker" cookie.
    if (cookie is found){
        connectionCookie = cookie we just found.
    }
    else {
        connectionCookie = cookie (uuid) generated by client (frontend app)
    }

    Attempt to connect to server and pass connectionCookie in the header of
    the websocket connection request.

    Server:
    Upon receiving a connection request from the client, the server looks at
    the cookie and sees if it already has a player associated with that
    cookie.
    If (association found){
        Retrieve the ConnectedClient object (which already has associations
        with a game player) and associate it with the websocket connection
    }
    else {
        Create new ConnectedClient for the connection and associate it with
        the websocket connection.
    }


6)  The user is now connected to the server via WS, and is able to see the
    game state update in realtime. At this point, all communication with the
    server is done via websockets.

    If (association was found && player was already in game){
        player is in game
    }

    Otherwise, if this is the first time that the player has navigated to
    the table URL (that is, they haven't joined the game yet, or they
    weren't in the game when they last accessed the UI), then they are not
    in the game. Table creation, navigating to table URL, and joining are
    separate actions. Only if you are already in game is navigating to table
    URL and joining done simultaneously.

    User can now click a button to join the game. Upon requesting to join
    the user is asked to provide the following information:

       Name - The player's display name.
       Buy-In - The amount of big blinds the user wants to buy in for.
       Admin? - True if requesting to join as admin. When table has no
           players, default is true. Otherwise default is false.
       SitDown? True if user wants to sit down right away. Default is true.
       Password - if user is joining as admin, they provide the passwd here

    The user submits the request to join the game over the WS connection.

    If (user is joining as an admin){
        If (correct password){
            server grants the request and updates the game state
        }
        else {
            return failure message "incorrect password"
        }
    }

    else {
        If (table requires admins to approve new players){
            server sends new player request to admins and waits for approval
        }
        else {
            server grants the request and updates the game state
        }
    }

7) The user has joined the game. If they are not yet sitting, they can sit
down, and play hands. If they are admin, they can perform administrative
tasks, etc.


=================================================
Sending Updates to Clients
=================================================

The server should broadcast the updated gamestate to all clients everytime the gamestate is updated.

The gamestate is updated when
    - A user performs an action (sends valid WS message to server)
    - A timer event occurs


=================================================
Service Responsibility Separation
=================================================

MessageService: 
    - receives incoming messages
    - asks ValidationService to validate them (legality of actions)
    - converts clientIDs to playerUUIDs
    - asks gameState to perform actions
    - sends responses/updates to clients
ValidationService:
    - Validates incoming action with respect to current gameState
    - Throws errors when input is invalid/illegal
GameStateManager:
    - Does no validation, assumes that it is only asked to do something when it can/should do it.
    - Performs structured updates to game state

PlayerManager, DeckManager, ClientManager:
    - Helper managers for updating game state. They do not udpate the game state themselves,
    but return objects that can be used in updates.
    - Unclear how necessary they are, and how to split responsibility cleanly between them
    and gameStateManager


For performing actions like bet, check, fold, etc, gameStateManager should not be receiving playerID
as an argument, because only one player can act a time. Validation layer should just make sure that
incoming action is coming from correct player, and only process it if that is the case.

Maybe gamePlayActions can be broken out into their own manager.


=================================================
Question of Responsibility Separation for State Management
=================================================
Approach 1
GameStateManager allows other services to update gameState

Pros
- GameStateManager is greatly reduced in size
- GameStateManager has less responsibility, less complex

Cons
- Other services that wish to update state need to interface with multiple services
- Complex updates that require more than one services will require logic to be in GameStateManager
- GameStateManager is no longer authoritative
- Circular dependency


Approach 2
GameStateManager uses other services/files as specific object helpers

Pros
- GameStateManager is slightly reduced in size
- GameStateManager can be used as sole interface for state updates
- GameStateManager remains authoritative

Cons
- GameStateManager will have a lot of glue methods that call the helpers

Approach 3 (lets try this one)
Services are grouped by semantics of update rather than gameState sub-field,
service functions can take entire game state, and return new GameState to
main GameStateManager which can then handle updating the source of truth state.

Pros
- GameStateManager is greatly reduced in size
- GameStateManager has less responsibility, less complex
- GameStateManager remains authoritative

Cons
- Unclear how to have a consistent separation by semantics
- Complex updates that require more than one services will require logic to be in GameStateManager (it seems that this would have been the case regardless.)
- Circular dependency


Main problem around picking approach is figuring out separation of responsibility, and dependency graph.
I think you can continue the same way right now, and once you identify where you are repeating yourself, then you
can try to abstract it away





