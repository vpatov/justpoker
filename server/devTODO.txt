- actual game play functionality (MVP)
- determine how to best use functional/redux patterns and avoid anti-pattern usage
- coordinate interfaces/models with UI and jules
- Design timing aspect of gameplay
- sitPlayerDown, and other similar methods are only mutating the players object.
        This should be the first thing you try to de-duplicate, you've now reached three code repeats.
- It seems like the gameStateManager file is going to become very bloated. Find the best way to ameliorate this.
- Consider replacing uuid string with uuid type
- Integrate https://github.com/goldfire/pokersolver for hand solving
- cleaner design would be to allow gameStateManager to assume that all operations it is being asked to perform are legal. Insert a validation layer between the messageService and the gameStateManager. 
- Having seats is convenient for processing, but it is duplication of data and you should avoid it for that reason.
        /*
        const seats: [number, string][] = Object.values(players).filter(player => player.seatNumber >= 0).map(
            (player) => [player.seatNumber, player.uuid]
        );
        seats.sort();
        */

- It would be good to be aware of the scenario when the (pertinent) ui state is different from the game state. This could be done by getting a fingerprint of the state on the ui side and including it in messages to the server. Server will check the incoming fingerprint and compare it to the last outgoing fingerprint and ensure they are the same. I imagine this would only be used for diagnostic purposes, to understand more about production conditions/states.

- Timer functionality
    // the UI should make it seem like user has X seconds to act, but the server
    // will allow X + 2 seconds to make up for network issues

    // There should be one global timer, and that is the only timer that is running.
    startGameTimer() {
        const serverTime = Date.now();
        this.gameState = {
            ...this.gameState,
            serverTime
        };

        this.gameTimer = setTimeout(
            this.timerFunc, this.gameState.gameParameters.timeToAct);
    }

    // looks at game state and determines
    timerFunc() {

    }
    

- System for queueing actions. For example, adding on chips, sitting out next hand, checking in the dark, etc.
- autoformat line length, put back in tslint: "max-line-length": [true, 80],


Done:
- server fetches connected client and associates it with websocket via cookie
- Map object is problematic to serialize to JSON. Consider replacing it with a simple object. Just be sure that it doesn't become a tricky soruce of bugs later. 
- Create filter that removes sensitive data from gameState object before sending it to UI (cards, cookies, etc)
- start game functionality 

